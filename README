Description translated by http://translate.google.com
------

ProCoGraM - generating music by means of evaluation of probabilistic tree grammars - similar to those used for natural language parsing. 

Program Description: 

1st A single grammar is used to generate a piece of music - or a single melodic line takowego. 
2nd The program works on the principle of iteration. At every step of the output grammar grammar generates derivatives which are evaluated by the user. 
3rd Rating is based on the generated track and listened to their votes. 
4th Grammar in the first step are completely random. The user selects the direction of music 
5th At any time the status of the program can be saved to a file and then resume at its own discretion. 
6th Supported is also the story - you can move backwards and forwards. 
7th You can listen to the selected grammar continuously. You can also save a sound sample file. 

Semantics of grammars: 

1st There is a finite set of terminal symbols. Each of them sets a tone (or rest) with its length of duration, etc. 
2nd Grammar includes starting symbol S. 
3rd For each symbol nieterminalnego E there is a group of context-free production of the form E -> W *, where W * is a sequence of zero or more symbols (terminal or non-terminal). Each production is attributed to the probability of occurrence, and they all add up to 1 (for each symbol E). 
4th Fresh nieterminalne symbols may be placed on him grammar, if necessary, through mutation. 

5th To grammar was correct, for each symbol should be nieterminalnego nonzero probability of generating terminal symbol. Otherwise, the machine generates a zapętli music. 

5th For each symbol, either: 
5.1. Expected position of the first terminal symbol generated from it after a full expansion is finite. 
5.2. The symbol goes into an empty string. 

6th This condition is unfortunately not sufficient. Example: {S -> St} 

Generate the music: 
5th Music is generated by evaluating the state of the machine. 
6th Initial state is an infinite sequence of symbols start: SSSSS .... 
7th At every step of evaluation we remove the first symbol of the state machine. If it is a terminal, then send him to play. Otherwise (nonterminals) choose randomly the production of which we have used and place the result of production at the beginning of the recording.

------
Original:

ProCoGraM - generowanie muzyki poprzez ewaluację drzew gramatyk probabilistycznych - podobnych do tych, które służą do parsowania języka naturalnego.

Opis programu:

1. Pojedyncza gramatyka służy do generowania utworu muzycznego - lub pojedynczej linii melodycznej takowego.
2. Program działa na zasadzie iteracji. Na każdym kroku z gramatyki wyjściowej generowane są gramatyki pochodne, które oceniane są przez użytkownika.
3. Ocena polega na odsłuchaniu wygenerowanego utworu i oddaniu głosu.
4. Gramatyki w pierwszym kroku są zupełnie losowe. Użytkownik wybiera kierunek rozwoju muzyki
5. W dowolnym momencie stan programu można zapisać do pliku i później wznowić wedle uznania.
6. Obsługiwana jest też historia - można się cofać i przechodzić do przodu.
7. Wybraną gramatykę można odsłuchać w sposób ciągły. Można też zapisać próbkę dźwiękową do pliku.

Semantyka gramatyk:

1. Istnieje skończony zbiór symboli terminalnych. Każdy z nich określa pewien dźwięk (lub pauzę) wraz z jego długością trwania itp.
2. Gramatyka zawiera symbol startowy S.
3. Dla każdego symbolu nieterminalnego E istnieje grupa produkcji bezkontekstowych postaci E -> W*, gdzie W* jest ciągiem zera lub więcej symboli (terminalnych lub nieterminalnych). Każda z produkcji ma przypisane prawdopodobieństwo wystąpienia, a wszystkie one sumują się do 1 (dla każdego symbolu E).
4. Świeże symbole nieterminalne mogą być wprowadzane go gramatyki w razie potrzeby na drodze mutacji.

5. Aby gramatyka była poprawna, dla każdego symbolu nieterminalnego powinno istnieć niezerowe prawdopodobieństwo wygenerowania symbolu terminalnego. W przeciwnym wypadku maszyna generująca muzykę zapętli się.

5. Dla każdego symbolu albo:
5.1. Oczekiwana pozycja pierwszego symbolu terminalnego wygenerowanego z niego po pełnym rozwinięciu jest skończona.
5.2. Symbol przechodzi w ciąg pusty.

6. Powyższy warunek nie jest niestety wystarczający. Przykład: { S -> St }

Generowanie muzyki:
5. Muzyka generowana jest przez ewaluację stanu maszyny.
6. Stanem początkowym jest nieskończony ciąg symboli startowych: SSSSS....
7. Na każdym kroku ewaluacji usuwamy pierwszy symbol ze stanu maszyny. Jeżeli jest to terminal, to przesyłamy go do odegrania. W przeciwnym wypadku (nieterminal) wybieramy losowo produkcję którą mamy zastosować i umieszczamy wynik produkcji na początku zapisu.